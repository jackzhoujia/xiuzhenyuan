<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<title>Document</title>
</head>

<body>

	<script>
		// this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象最近的对象

		// function a() {
		// 	var user = "jj";
		// 	console.log(this.user);
		// 	console.log(this);
		// }
		// window.a();

		// var o = {
		// 	user: "jj",
		// 	fn: function () {
		// 		console.log(this.user)
		// 	}
		// }
		// window.o.fn();

		
		// var o = {
		// 	a:10,
		// 	b:{
		// 		fn:function(){
		// 			console.log(this.a)
		// 		}
		// 	}
		// }
		// window.o.b.fn();

		// var o ={
		// 	a:10,
		// 	b:{
		// 		a:12,
		// 		fn:function(){
		// 			console.log(this.a);
		// 		}
		// 	}
		// }
		// var j = o.b.fn();

		// var point = {
		// 	x: 0,
		// 	y: 0,
		// 	moveTo: function (x, y) {
		// 		this.x = this.x + x;
		// 		this.y = this.y + y;
		// 	}
		// };
		// window.point.moveTo(1, 1) //this 绑定到当前对象，即 point 对象
		// console.log(point.x);
		// console.log(point.y)

		// function makeNoSense(x) {
		// 	this.x = x;
		// }

		// makeNoSense(5);
		// console.log(x); // x 已经成为一个值为 5 的全局变量

		// 对于内部函数， 即声明在另外一个函数体内的函数， 这种绑定到全局对象的方式会产生另外一个问题。 
		// 我们仍然以前面提到的 point 对象为例， 这次我们希望在 moveTo 方法内定义两个函数， 分别将 x， y 坐标进行平移。 
		// 结果可能出乎大家意料， 不仅 point 对象没有移动， 反而多出两个全局变量 x， y。
		// var point = {
		// 	x: 0,
		// 	y: 0,
		// 	moveTo: function (x, y) {
		// 		// 内部函数
		// 		var that = this;
		// 		var moveX = function (x) {
		// 			that.x = x; //this 绑定到了哪里？
		// 		};
		// 		// 内部函数
		// 		var moveY = function (y) {
		// 			that.y = y; //this 绑定到了哪里？
		// 		};
		// 		moveX(x);
		// 		moveY(y);
		// 	}
		// };
		// point.moveTo(1, 1);
		// console.log(point.x); 
		// console.log(point.y);

		// console.log(x);
		// console.log(y);

		// var f = function () {
		// 	console.log(this.x);
		// }
		// var x = 1;
		// var obj = {
		// 	f: f,
		// 	x: 2,
		// };

		// // 单独执行
		// window.f() // 1
		// // obj 环境执行
		// window.obj.f() // 2

		"use strict";
		function test(){
			console.log(this);
		}
		test();
	</script>
</body>

</html>